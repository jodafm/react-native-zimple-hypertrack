import Foundation

final class EventsTableManager: AbstractDatabaseProtocol {
  struct Input {
    let tableName: String
    let dbManager: AbstractDatabase
  }

  typealias T = Event

  // numeric autogenerated id, primary key
  let fieldEventID = "eventID"

  let fieldId = "id"
  let fieldSortedKey = "sortedKey"
  let fieldType = "type"
  let fieldData = "data"
  let fieldRecordedAt = "recorded_at"

  private let tableName: String
  private let dbManager: AbstractDatabase

  init(withInput input: Input) {
    tableName = input.tableName
    dbManager = input.dbManager
    createTable(withName: tableName)
  }

  private func createTable(withName name: String) {
    let sql =
      "create table \(name) (\(fieldEventID) integer primary key autoincrement, \(fieldId) text not null, \(fieldType) text not null, \(fieldData) text not null, \(fieldRecordedAt) text not null, \(fieldSortedKey) text not null)"
    do { try dbManager.createTable(sql) } catch {}
  }

  func insert(items: [T], result: @escaping (DataBaseResult<[T]>) -> Void) {
    let values = items.map { item in

      "(null, '\(item.id)', '\(item.type.rawValue)', '\(item.data)', '\(item.recordedAt)', '\(item.sortedKey)')"
    }.joined(separator: ",")
    let sql =
      "insert into \(tableName) (\(fieldEventID), \(fieldId), \(fieldType), \(fieldData), \(fieldRecordedAt), \(fieldSortedKey)) values \(values);"
    do {
      try dbManager.insert(sql)
      result(DataBaseResult.success(items))
    } catch { result(DataBaseResult.failure(error.localizedDescription)) }
  }

  func delete(items: [T], result: @escaping (DataBaseResult<[T]>) -> Void) {
    let formattedIds = items.map { item in "'\(item.id)'" }.joined(
      separator: ","
    )
    let sql = "delete from \(tableName) where \(fieldId) IN (\(formattedIds));"
    do {
      try dbManager.delete(sql)
      result(DataBaseResult.success(items))
    } catch { result(DataBaseResult.failure(error.localizedDescription)) }
  }

  func fetch(count: UInt, result: @escaping (DataBaseResult<[T]>) -> Void) {
    // swiftlint:disable empty_count
    let sql = "select * from \(tableName)\(count <= 0 ? "" : " limit \(count)")"
    // swiftlint:enable empty_count
    do { result(DataBaseResult.success(try dbManager.select(sql))) } catch {
      result(DataBaseResult.failure(error.localizedDescription))
    }
  }

  func sortedFetch(
    count: UInt,
    result: @escaping (DataBaseResult<[T]>) -> Void
  ) {
    // swiftlint:disable empty_count
    let sql =
      "select * from \(tableName) order by \(fieldSortedKey) desc\(count <= 0 ? "" : " limit \(count)")"
    // swiftlint:enable empty_count
    do { result(DataBaseResult.success(try dbManager.select(sql))) } catch {
      result(DataBaseResult.failure(error.localizedDescription))
    }
  }

  func deleteAll(result: @escaping (_ status: Bool) -> Void) {
    let sql = "DELETE from \(tableName)"
    do {
      try dbManager.delete(sql)
      result(true)
    } catch { result(false) }
  }
}
